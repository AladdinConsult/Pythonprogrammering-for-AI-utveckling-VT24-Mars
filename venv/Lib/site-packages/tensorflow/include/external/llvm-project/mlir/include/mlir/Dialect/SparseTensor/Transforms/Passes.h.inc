/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_LOWERFOREACHTOSCF
#define GEN_PASS_DECL_LOWERSPARSEOPSTOFOREACH
#define GEN_PASS_DECL_PRESPARSIFICATIONREWRITE
#define GEN_PASS_DECL_SPARSEASSEMBLER
#define GEN_PASS_DECL_SPARSEBUFFERREWRITE
#define GEN_PASS_DECL_SPARSEGPUCODEGEN
#define GEN_PASS_DECL_SPARSEREINTERPRETMAP
#define GEN_PASS_DECL_SPARSETENSORCODEGEN
#define GEN_PASS_DECL_SPARSETENSORCONVERSIONPASS
#define GEN_PASS_DECL_SPARSEVECTORIZATION
#define GEN_PASS_DECL_SPARSIFICATIONANDBUFFERIZATION
#define GEN_PASS_DECL_SPARSIFICATIONPASS
#define GEN_PASS_DECL_STAGESPARSEOPERATIONS
#define GEN_PASS_DECL_STORAGESPECIFIERTOLLVM
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// LowerForeachToSCF
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERFOREACHTOSCF
#undef GEN_PASS_DECL_LOWERFOREACHTOSCF
#endif // GEN_PASS_DECL_LOWERFOREACHTOSCF
#ifdef GEN_PASS_DEF_LOWERFOREACHTOSCF
namespace impl {

template <typename DerivedT>
class LowerForeachToSCFBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LowerForeachToSCFBase;

  LowerForeachToSCFBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerForeachToSCFBase(const LowerForeachToSCFBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-sparse-foreach-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "lower-sparse-foreach-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Decompose a complex sparse operation into multiple stages"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerForeachToSCF");
  }
  ::llvm::StringRef getName() const override { return "LowerForeachToSCF"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerForeachToSCFBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERFOREACHTOSCF
#endif // GEN_PASS_DEF_LOWERFOREACHTOSCF

//===----------------------------------------------------------------------===//
// LowerSparseOpsToForeach
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERSPARSEOPSTOFOREACH
struct LowerSparseOpsToForeachOptions {
  bool enableRuntimeLibrary = true;
  bool enableConvert = true;
};
#undef GEN_PASS_DECL_LOWERSPARSEOPSTOFOREACH
#endif // GEN_PASS_DECL_LOWERSPARSEOPSTOFOREACH
#ifdef GEN_PASS_DEF_LOWERSPARSEOPSTOFOREACH
namespace impl {

template <typename DerivedT>
class LowerSparseOpsToForeachBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LowerSparseOpsToForeachBase;

  LowerSparseOpsToForeachBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerSparseOpsToForeachBase(const LowerSparseOpsToForeachBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-sparse-ops-to-foreach");
  }
  ::llvm::StringRef getArgument() const override { return "lower-sparse-ops-to-foreach"; }

  ::llvm::StringRef getDescription() const override { return "Applies sparse tensor rewriting rules after sparsification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerSparseOpsToForeach");
  }
  ::llvm::StringRef getName() const override { return "LowerSparseOpsToForeach"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerSparseOpsToForeachBase<DerivedT>)

  LowerSparseOpsToForeachBase(const LowerSparseOpsToForeachOptions &options) : LowerSparseOpsToForeachBase() {
    enableRuntimeLibrary = options.enableRuntimeLibrary;
    enableConvert = options.enableConvert;
  }
protected:
  ::mlir::Pass::Option<bool> enableRuntimeLibrary{*this, "enable-runtime-library", ::llvm::cl::desc("Enable runtime library for manipulating sparse tensors"), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<bool> enableConvert{*this, "enable-convert", ::llvm::cl::desc("Enable rewriting rules for the convert operator"), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERSPARSEOPSTOFOREACH
#endif // GEN_PASS_DEF_LOWERSPARSEOPSTOFOREACH

//===----------------------------------------------------------------------===//
// PreSparsificationRewrite
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PRESPARSIFICATIONREWRITE
#undef GEN_PASS_DECL_PRESPARSIFICATIONREWRITE
#endif // GEN_PASS_DECL_PRESPARSIFICATIONREWRITE
#ifdef GEN_PASS_DEF_PRESPARSIFICATIONREWRITE
namespace impl {

template <typename DerivedT>
class PreSparsificationRewriteBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PreSparsificationRewriteBase;

  PreSparsificationRewriteBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PreSparsificationRewriteBase(const PreSparsificationRewriteBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("pre-sparsification-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "pre-sparsification-rewrite"; }

  ::llvm::StringRef getDescription() const override { return "Applies sparse tensor rewriting rules prior to sparsification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PreSparsificationRewrite");
  }
  ::llvm::StringRef getName() const override { return "PreSparsificationRewrite"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PreSparsificationRewriteBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PRESPARSIFICATIONREWRITE
#endif // GEN_PASS_DEF_PRESPARSIFICATIONREWRITE

//===----------------------------------------------------------------------===//
// SparseAssembler
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SPARSEASSEMBLER
#undef GEN_PASS_DECL_SPARSEASSEMBLER
#endif // GEN_PASS_DECL_SPARSEASSEMBLER
#ifdef GEN_PASS_DEF_SPARSEASSEMBLER
namespace impl {

template <typename DerivedT>
class SparseAssemblerBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparseAssemblerBase;

  SparseAssemblerBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseAssemblerBase(const SparseAssemblerBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-assembler");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-assembler"; }

  ::llvm::StringRef getDescription() const override { return "Add [dis]assemble operations on external sparse tensors"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseAssembler");
  }
  ::llvm::StringRef getName() const override { return "SparseAssembler"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<sparse_tensor::SparseTensorDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseAssemblerBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SPARSEASSEMBLER
#endif // GEN_PASS_DEF_SPARSEASSEMBLER

//===----------------------------------------------------------------------===//
// SparseBufferRewrite
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SPARSEBUFFERREWRITE
struct SparseBufferRewriteOptions {
  bool enableBufferInitialization = false;
};
#undef GEN_PASS_DECL_SPARSEBUFFERREWRITE
#endif // GEN_PASS_DECL_SPARSEBUFFERREWRITE
#ifdef GEN_PASS_DEF_SPARSEBUFFERREWRITE
namespace impl {

template <typename DerivedT>
class SparseBufferRewriteBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparseBufferRewriteBase;

  SparseBufferRewriteBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseBufferRewriteBase(const SparseBufferRewriteBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-buffer-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-buffer-rewrite"; }

  ::llvm::StringRef getDescription() const override { return "Rewrite sparse primitives on buffers to actual code"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseBufferRewrite");
  }
  ::llvm::StringRef getName() const override { return "SparseBufferRewrite"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseBufferRewriteBase<DerivedT>)

  SparseBufferRewriteBase(const SparseBufferRewriteOptions &options) : SparseBufferRewriteBase() {
    enableBufferInitialization = options.enableBufferInitialization;
  }
protected:
  ::mlir::Pass::Option<bool> enableBufferInitialization{*this, "enable-buffer-initialization", ::llvm::cl::desc("Enable zero-initialization of the memory buffers"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SPARSEBUFFERREWRITE
#endif // GEN_PASS_DEF_SPARSEBUFFERREWRITE

//===----------------------------------------------------------------------===//
// SparseGPUCodegen
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SPARSEGPUCODEGEN
struct SparseGPUCodegenOptions {
  int32_t numThreads = 1024;
  bool enableRuntimeLibrary = true;
};
#undef GEN_PASS_DECL_SPARSEGPUCODEGEN
#endif // GEN_PASS_DECL_SPARSEGPUCODEGEN
#ifdef GEN_PASS_DEF_SPARSEGPUCODEGEN
namespace impl {

template <typename DerivedT>
class SparseGPUCodegenBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparseGPUCodegenBase;

  SparseGPUCodegenBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseGPUCodegenBase(const SparseGPUCodegenBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-gpu-codegen");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-gpu-codegen"; }

  ::llvm::StringRef getDescription() const override { return "Generates GPU code during sparsification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseGPUCodegen");
  }
  ::llvm::StringRef getName() const override { return "SparseGPUCodegen"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<gpu::GPUDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseGPUCodegenBase<DerivedT>)

  SparseGPUCodegenBase(const SparseGPUCodegenOptions &options) : SparseGPUCodegenBase() {
    numThreads = options.numThreads;
    enableRuntimeLibrary = options.enableRuntimeLibrary;
  }
protected:
  ::mlir::Pass::Option<int32_t> numThreads{*this, "num-threads", ::llvm::cl::desc("Sets the number of GPU threads"), ::llvm::cl::init(1024)};
  ::mlir::Pass::Option<bool> enableRuntimeLibrary{*this, "enable-runtime-library", ::llvm::cl::desc("Enable runtime library for manipulating sparse tensors"), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SPARSEGPUCODEGEN
#endif // GEN_PASS_DEF_SPARSEGPUCODEGEN

//===----------------------------------------------------------------------===//
// SparseReinterpretMap
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SPARSEREINTERPRETMAP
struct SparseReinterpretMapOptions {
  mlir::ReinterpretMapScope scope = mlir::ReinterpretMapScope::kAll;
};
#undef GEN_PASS_DECL_SPARSEREINTERPRETMAP
#endif // GEN_PASS_DECL_SPARSEREINTERPRETMAP
#ifdef GEN_PASS_DEF_SPARSEREINTERPRETMAP
namespace impl {

template <typename DerivedT>
class SparseReinterpretMapBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparseReinterpretMapBase;

  SparseReinterpretMapBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseReinterpretMapBase(const SparseReinterpretMapBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-reinterpret-map");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-reinterpret-map"; }

  ::llvm::StringRef getDescription() const override { return "Reinterprets sparse tensor type mappings"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseReinterpretMap");
  }
  ::llvm::StringRef getName() const override { return "SparseReinterpretMap"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseReinterpretMapBase<DerivedT>)

  SparseReinterpretMapBase(const SparseReinterpretMapOptions &options) : SparseReinterpretMapBase() {
    scope = options.scope;
  }
protected:
  ::mlir::Pass::Option<mlir::ReinterpretMapScope> scope{*this, "scope", ::llvm::cl::desc("Set the reiterpretation scope"), ::llvm::cl::init(mlir::ReinterpretMapScope::kAll), llvm::cl::values(
         clEnumValN(mlir::ReinterpretMapScope::kAll, "all",
                    "Run on every applicable operations."),
         clEnumValN(mlir::ReinterpretMapScope::kGenericOnly,
                    "only-generic",
                    "Run only on linalg.generic operations."),
         clEnumValN(mlir::ReinterpretMapScope::kExceptGeneric,
                    "except-generic",
                    "Run on operations expect linalg.generic (e.g., foreach)"))};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SPARSEREINTERPRETMAP
#endif // GEN_PASS_DEF_SPARSEREINTERPRETMAP

//===----------------------------------------------------------------------===//
// SparseTensorCodegen
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SPARSETENSORCODEGEN
struct SparseTensorCodegenOptions {
  bool enableBufferInitialization = false;
  bool createSparseDeallocs = true;
};
#undef GEN_PASS_DECL_SPARSETENSORCODEGEN
#endif // GEN_PASS_DECL_SPARSETENSORCODEGEN
#ifdef GEN_PASS_DEF_SPARSETENSORCODEGEN
namespace impl {

template <typename DerivedT>
class SparseTensorCodegenBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparseTensorCodegenBase;

  SparseTensorCodegenBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseTensorCodegenBase(const SparseTensorCodegenBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-tensor-codegen");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-tensor-codegen"; }

  ::llvm::StringRef getDescription() const override { return "Convert sparse tensors and primitives to actual code"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseTensorCodegen");
  }
  ::llvm::StringRef getName() const override { return "SparseTensorCodegen"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseTensorCodegenBase<DerivedT>)

  SparseTensorCodegenBase(const SparseTensorCodegenOptions &options) : SparseTensorCodegenBase() {
    enableBufferInitialization = options.enableBufferInitialization;
    createSparseDeallocs = options.createSparseDeallocs;
  }
protected:
  ::mlir::Pass::Option<bool> enableBufferInitialization{*this, "enable-buffer-initialization", ::llvm::cl::desc("Enable zero-initialization of the memory buffers"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> createSparseDeallocs{*this, "create-sparse-deallocs", ::llvm::cl::desc("Specify if the temporary buffers created by the sparse compiler should be deallocated. For compatibility with core bufferization passes. This option is only used when enable-runtime-library=false. See also create-deallocs for BufferizationOption."), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SPARSETENSORCODEGEN
#endif // GEN_PASS_DEF_SPARSETENSORCODEGEN

//===----------------------------------------------------------------------===//
// SparseTensorConversionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SPARSETENSORCONVERSIONPASS
#undef GEN_PASS_DECL_SPARSETENSORCONVERSIONPASS
#endif // GEN_PASS_DECL_SPARSETENSORCONVERSIONPASS
#ifdef GEN_PASS_DEF_SPARSETENSORCONVERSIONPASS
namespace impl {

template <typename DerivedT>
class SparseTensorConversionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparseTensorConversionPassBase;

  SparseTensorConversionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseTensorConversionPassBase(const SparseTensorConversionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-tensor-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-tensor-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Convert sparse tensors and primitives to library calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseTensorConversionPass");
  }
  ::llvm::StringRef getName() const override { return "SparseTensorConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseTensorConversionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SPARSETENSORCONVERSIONPASS
#endif // GEN_PASS_DEF_SPARSETENSORCONVERSIONPASS

//===----------------------------------------------------------------------===//
// SparseVectorization
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SPARSEVECTORIZATION
struct SparseVectorizationOptions {
  int32_t vectorLength = 0;
  bool enableVLAVectorization = false;
  bool enableSIMDIndex32 = false;
};
#undef GEN_PASS_DECL_SPARSEVECTORIZATION
#endif // GEN_PASS_DECL_SPARSEVECTORIZATION
#ifdef GEN_PASS_DEF_SPARSEVECTORIZATION
namespace impl {

template <typename DerivedT>
class SparseVectorizationBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparseVectorizationBase;

  SparseVectorizationBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseVectorizationBase(const SparseVectorizationBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-vectorization");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-vectorization"; }

  ::llvm::StringRef getDescription() const override { return "Vectorizes loops after sparsification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseVectorization");
  }
  ::llvm::StringRef getName() const override { return "SparseVectorization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseVectorizationBase<DerivedT>)

  SparseVectorizationBase(const SparseVectorizationOptions &options) : SparseVectorizationBase() {
    vectorLength = options.vectorLength;
    enableVLAVectorization = options.enableVLAVectorization;
    enableSIMDIndex32 = options.enableSIMDIndex32;
  }
protected:
  ::mlir::Pass::Option<int32_t> vectorLength{*this, "vl", ::llvm::cl::desc("Set the vector length (use 0 to disable vectorization)"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<bool> enableVLAVectorization{*this, "enable-vla-vectorization", ::llvm::cl::desc("Enable vector length agnostic vectorization"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> enableSIMDIndex32{*this, "enable-simd-index32", ::llvm::cl::desc("Enable i32 indexing into vectors (for efficient gather/scatter)"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SPARSEVECTORIZATION
#endif // GEN_PASS_DEF_SPARSEVECTORIZATION

//===----------------------------------------------------------------------===//
// SparsificationAndBufferization
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SPARSIFICATIONANDBUFFERIZATION
#undef GEN_PASS_DECL_SPARSIFICATIONANDBUFFERIZATION
#endif // GEN_PASS_DECL_SPARSIFICATIONANDBUFFERIZATION
#ifdef GEN_PASS_DEF_SPARSIFICATIONANDBUFFERIZATION
namespace impl {

template <typename DerivedT>
class SparsificationAndBufferizationBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparsificationAndBufferizationBase;

  SparsificationAndBufferizationBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparsificationAndBufferizationBase(const SparsificationAndBufferizationBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparsification-and-bufferization");
  }
  ::llvm::StringRef getArgument() const override { return "sparsification-and-bufferization"; }

  ::llvm::StringRef getDescription() const override { return "Mini-pipeline that combines bufferization and sparsifiation"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparsificationAndBufferization");
  }
  ::llvm::StringRef getName() const override { return "SparsificationAndBufferization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<gpu::GPUDialect>();
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparsificationAndBufferizationBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SPARSIFICATIONANDBUFFERIZATION
#endif // GEN_PASS_DEF_SPARSIFICATIONANDBUFFERIZATION

//===----------------------------------------------------------------------===//
// SparsificationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SPARSIFICATIONPASS
struct SparsificationPassOptions {
  mlir::SparseParallelizationStrategy parallelization = mlir::SparseParallelizationStrategy::kNone;
  mlir::SparseEmitStrategy sparseEmitStrategy = mlir::SparseEmitStrategy::kFunctional;
  bool enableRuntimeLibrary = true;
};
#undef GEN_PASS_DECL_SPARSIFICATIONPASS
#endif // GEN_PASS_DECL_SPARSIFICATIONPASS
#ifdef GEN_PASS_DEF_SPARSIFICATIONPASS
namespace impl {

template <typename DerivedT>
class SparsificationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparsificationPassBase;

  SparsificationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparsificationPassBase(const SparsificationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparsification");
  }
  ::llvm::StringRef getArgument() const override { return "sparsification"; }

  ::llvm::StringRef getDescription() const override { return "Automatically generate sparse tensor code from sparse tensor types"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparsificationPass");
  }
  ::llvm::StringRef getName() const override { return "SparsificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparsificationPassBase<DerivedT>)

  SparsificationPassBase(const SparsificationPassOptions &options) : SparsificationPassBase() {
    parallelization = options.parallelization;
    sparseEmitStrategy = options.sparseEmitStrategy;
    enableRuntimeLibrary = options.enableRuntimeLibrary;
  }
protected:
  ::mlir::Pass::Option<mlir::SparseParallelizationStrategy> parallelization{*this, "parallelization-strategy", ::llvm::cl::desc("Set the parallelization strategy"), ::llvm::cl::init(mlir::SparseParallelizationStrategy::kNone), llvm::cl::values(
             clEnumValN(mlir::SparseParallelizationStrategy::kNone, "none",
                        "Turn off sparse parallelization."),
             clEnumValN(mlir::SparseParallelizationStrategy::kDenseOuterLoop,
                        "dense-outer-loop",
                        "Enable dense outer loop sparse parallelization."),
             clEnumValN(mlir::SparseParallelizationStrategy::kAnyStorageOuterLoop,
                        "any-storage-outer-loop",
                        "Enable sparse parallelization regardless of storage for the outer loop."),
             clEnumValN(mlir::SparseParallelizationStrategy::kDenseAnyLoop,
                        "dense-any-loop",
                        "Enable dense parallelization for any loop."),
             clEnumValN(mlir::SparseParallelizationStrategy::kAnyStorageAnyLoop,
                        "any-storage-any-loop",
                        "Enable sparse parallelization for any storage and loop."))};
  ::mlir::Pass::Option<mlir::SparseEmitStrategy> sparseEmitStrategy{*this, "sparse-emit-strategy", ::llvm::cl::desc("Emit functional code or interfaces (to debug) for sparse loops"), ::llvm::cl::init(mlir::SparseEmitStrategy::kFunctional), llvm::cl::values(
             clEnumValN(mlir::SparseEmitStrategy::kFunctional, "functional",
                        "Emit functional code."),
             clEnumValN(mlir::SparseEmitStrategy::kDebugInterface, "debug-interface",
                        "Emit non-functional but easy-to-read interfaces to debug."))};
  ::mlir::Pass::Option<bool> enableRuntimeLibrary{*this, "enable-runtime-library", ::llvm::cl::desc("Enable runtime library for manipulating sparse tensors"), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SPARSIFICATIONPASS
#endif // GEN_PASS_DEF_SPARSIFICATIONPASS

//===----------------------------------------------------------------------===//
// StageSparseOperations
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STAGESPARSEOPERATIONS
#undef GEN_PASS_DECL_STAGESPARSEOPERATIONS
#endif // GEN_PASS_DECL_STAGESPARSEOPERATIONS
#ifdef GEN_PASS_DEF_STAGESPARSEOPERATIONS
namespace impl {

template <typename DerivedT>
class StageSparseOperationsBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StageSparseOperationsBase;

  StageSparseOperationsBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StageSparseOperationsBase(const StageSparseOperationsBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stage-sparse-ops");
  }
  ::llvm::StringRef getArgument() const override { return "stage-sparse-ops"; }

  ::llvm::StringRef getDescription() const override { return "Decompose a complex sparse operation into multiple stages"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StageSparseOperations");
  }
  ::llvm::StringRef getName() const override { return "StageSparseOperations"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StageSparseOperationsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_STAGESPARSEOPERATIONS
#endif // GEN_PASS_DEF_STAGESPARSEOPERATIONS

//===----------------------------------------------------------------------===//
// StorageSpecifierToLLVM
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STORAGESPECIFIERTOLLVM
#undef GEN_PASS_DECL_STORAGESPECIFIERTOLLVM
#endif // GEN_PASS_DECL_STORAGESPECIFIERTOLLVM
#ifdef GEN_PASS_DEF_STORAGESPECIFIERTOLLVM
namespace impl {

template <typename DerivedT>
class StorageSpecifierToLLVMBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StorageSpecifierToLLVMBase;

  StorageSpecifierToLLVMBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StorageSpecifierToLLVMBase(const StorageSpecifierToLLVMBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-storage-specifier-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-storage-specifier-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lower sparse storage specifer to llvm structure"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StorageSpecifierToLLVM");
  }
  ::llvm::StringRef getName() const override { return "StorageSpecifierToLLVM"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StorageSpecifierToLLVMBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_STORAGESPECIFIERTOLLVM
#endif // GEN_PASS_DEF_STORAGESPECIFIERTOLLVM
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// LowerForeachToSCF Registration
//===----------------------------------------------------------------------===//

inline void registerLowerForeachToSCF() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLowerForeachToSCFPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerForeachToSCFPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLowerForeachToSCFPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerSparseOpsToForeach Registration
//===----------------------------------------------------------------------===//

inline void registerLowerSparseOpsToForeach() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLowerSparseOpsToForeachPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerSparseOpsToForeachPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createLowerSparseOpsToForeachPass();
  });
}

//===----------------------------------------------------------------------===//
// PreSparsificationRewrite Registration
//===----------------------------------------------------------------------===//

inline void registerPreSparsificationRewrite() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createPreSparsificationRewritePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPreSparsificationRewritePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createPreSparsificationRewritePass();
  });
}

//===----------------------------------------------------------------------===//
// SparseAssembler Registration
//===----------------------------------------------------------------------===//

inline void registerSparseAssembler() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparseAssembler();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSparseAssemblerPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparseAssembler();
  });
}

//===----------------------------------------------------------------------===//
// SparseBufferRewrite Registration
//===----------------------------------------------------------------------===//

inline void registerSparseBufferRewrite() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparseBufferRewritePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSparseBufferRewritePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparseBufferRewritePass();
  });
}

//===----------------------------------------------------------------------===//
// SparseGPUCodegen Registration
//===----------------------------------------------------------------------===//

inline void registerSparseGPUCodegen() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparseGPUCodegenPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSparseGPUCodegenPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparseGPUCodegenPass();
  });
}

//===----------------------------------------------------------------------===//
// SparseReinterpretMap Registration
//===----------------------------------------------------------------------===//

inline void registerSparseReinterpretMap() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparseReinterpretMapPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSparseReinterpretMapPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparseReinterpretMapPass();
  });
}

//===----------------------------------------------------------------------===//
// SparseTensorCodegen Registration
//===----------------------------------------------------------------------===//

inline void registerSparseTensorCodegen() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparseTensorCodegenPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSparseTensorCodegenPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparseTensorCodegenPass();
  });
}

//===----------------------------------------------------------------------===//
// SparseTensorConversionPass Registration
//===----------------------------------------------------------------------===//

inline void registerSparseTensorConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparseTensorConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSparseTensorConversionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparseTensorConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// SparseVectorization Registration
//===----------------------------------------------------------------------===//

inline void registerSparseVectorization() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparseVectorizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSparseVectorizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparseVectorizationPass();
  });
}

//===----------------------------------------------------------------------===//
// SparsificationAndBufferization Registration
//===----------------------------------------------------------------------===//

inline void registerSparsificationAndBufferization() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparsificationAndBufferizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSparsificationAndBufferizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparsificationAndBufferizationPass();
  });
}

//===----------------------------------------------------------------------===//
// SparsificationPass Registration
//===----------------------------------------------------------------------===//

inline void registerSparsificationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparsificationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSparsificationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createSparsificationPass();
  });
}

//===----------------------------------------------------------------------===//
// StageSparseOperations Registration
//===----------------------------------------------------------------------===//

inline void registerStageSparseOperations() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createStageSparseOperationsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStageSparseOperationsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createStageSparseOperationsPass();
  });
}

//===----------------------------------------------------------------------===//
// StorageSpecifierToLLVM Registration
//===----------------------------------------------------------------------===//

inline void registerStorageSpecifierToLLVM() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createStorageSpecifierToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStorageSpecifierToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createStorageSpecifierToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// SparseTensor Registration
//===----------------------------------------------------------------------===//

inline void registerSparseTensorPasses() {
  registerLowerForeachToSCF();
  registerLowerSparseOpsToForeach();
  registerPreSparsificationRewrite();
  registerSparseAssembler();
  registerSparseBufferRewrite();
  registerSparseGPUCodegen();
  registerSparseReinterpretMap();
  registerSparseTensorCodegen();
  registerSparseTensorConversionPass();
  registerSparseVectorization();
  registerSparsificationAndBufferization();
  registerSparsificationPass();
  registerStageSparseOperations();
  registerStorageSpecifierToLLVM();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class LowerForeachToSCFBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = LowerForeachToSCFBase;

  LowerForeachToSCFBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerForeachToSCFBase(const LowerForeachToSCFBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-sparse-foreach-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "lower-sparse-foreach-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Decompose a complex sparse operation into multiple stages"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerForeachToSCF");
  }
  ::llvm::StringRef getName() const override { return "LowerForeachToSCF"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerForeachToSCFBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerSparseOpsToForeachBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = LowerSparseOpsToForeachBase;

  LowerSparseOpsToForeachBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerSparseOpsToForeachBase(const LowerSparseOpsToForeachBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("lower-sparse-ops-to-foreach");
  }
  ::llvm::StringRef getArgument() const override { return "lower-sparse-ops-to-foreach"; }

  ::llvm::StringRef getDescription() const override { return "Applies sparse tensor rewriting rules after sparsification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerSparseOpsToForeach");
  }
  ::llvm::StringRef getName() const override { return "LowerSparseOpsToForeach"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerSparseOpsToForeachBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> enableRuntimeLibrary{*this, "enable-runtime-library", ::llvm::cl::desc("Enable runtime library for manipulating sparse tensors"), ::llvm::cl::init(true)};
  ::mlir::Pass::Option<bool> enableConvert{*this, "enable-convert", ::llvm::cl::desc("Enable rewriting rules for the convert operator"), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class PreSparsificationRewriteBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = PreSparsificationRewriteBase;

  PreSparsificationRewriteBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PreSparsificationRewriteBase(const PreSparsificationRewriteBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("pre-sparsification-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "pre-sparsification-rewrite"; }

  ::llvm::StringRef getDescription() const override { return "Applies sparse tensor rewriting rules prior to sparsification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PreSparsificationRewrite");
  }
  ::llvm::StringRef getName() const override { return "PreSparsificationRewrite"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PreSparsificationRewriteBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SparseAssemblerBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparseAssemblerBase;

  SparseAssemblerBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseAssemblerBase(const SparseAssemblerBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-assembler");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-assembler"; }

  ::llvm::StringRef getDescription() const override { return "Add [dis]assemble operations on external sparse tensors"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseAssembler");
  }
  ::llvm::StringRef getName() const override { return "SparseAssembler"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<sparse_tensor::SparseTensorDialect>();
    registry.insert<tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseAssemblerBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SparseBufferRewriteBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparseBufferRewriteBase;

  SparseBufferRewriteBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseBufferRewriteBase(const SparseBufferRewriteBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-buffer-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-buffer-rewrite"; }

  ::llvm::StringRef getDescription() const override { return "Rewrite sparse primitives on buffers to actual code"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseBufferRewrite");
  }
  ::llvm::StringRef getName() const override { return "SparseBufferRewrite"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseBufferRewriteBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> enableBufferInitialization{*this, "enable-buffer-initialization", ::llvm::cl::desc("Enable zero-initialization of the memory buffers"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class SparseGPUCodegenBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparseGPUCodegenBase;

  SparseGPUCodegenBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseGPUCodegenBase(const SparseGPUCodegenBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-gpu-codegen");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-gpu-codegen"; }

  ::llvm::StringRef getDescription() const override { return "Generates GPU code during sparsification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseGPUCodegen");
  }
  ::llvm::StringRef getName() const override { return "SparseGPUCodegen"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<gpu::GPUDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseGPUCodegenBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int32_t> numThreads{*this, "num-threads", ::llvm::cl::desc("Sets the number of GPU threads"), ::llvm::cl::init(1024)};
  ::mlir::Pass::Option<bool> enableRuntimeLibrary{*this, "enable-runtime-library", ::llvm::cl::desc("Enable runtime library for manipulating sparse tensors"), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class SparseReinterpretMapBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparseReinterpretMapBase;

  SparseReinterpretMapBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseReinterpretMapBase(const SparseReinterpretMapBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-reinterpret-map");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-reinterpret-map"; }

  ::llvm::StringRef getDescription() const override { return "Reinterprets sparse tensor type mappings"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseReinterpretMap");
  }
  ::llvm::StringRef getName() const override { return "SparseReinterpretMap"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseReinterpretMapBase<DerivedT>)

protected:
  ::mlir::Pass::Option<mlir::ReinterpretMapScope> scope{*this, "scope", ::llvm::cl::desc("Set the reiterpretation scope"), ::llvm::cl::init(mlir::ReinterpretMapScope::kAll), llvm::cl::values(
         clEnumValN(mlir::ReinterpretMapScope::kAll, "all",
                    "Run on every applicable operations."),
         clEnumValN(mlir::ReinterpretMapScope::kGenericOnly,
                    "only-generic",
                    "Run only on linalg.generic operations."),
         clEnumValN(mlir::ReinterpretMapScope::kExceptGeneric,
                    "except-generic",
                    "Run on operations expect linalg.generic (e.g., foreach)"))};
};

template <typename DerivedT>
class SparseTensorCodegenBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparseTensorCodegenBase;

  SparseTensorCodegenBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseTensorCodegenBase(const SparseTensorCodegenBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-tensor-codegen");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-tensor-codegen"; }

  ::llvm::StringRef getDescription() const override { return "Convert sparse tensors and primitives to actual code"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseTensorCodegen");
  }
  ::llvm::StringRef getName() const override { return "SparseTensorCodegen"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseTensorCodegenBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> enableBufferInitialization{*this, "enable-buffer-initialization", ::llvm::cl::desc("Enable zero-initialization of the memory buffers"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> createSparseDeallocs{*this, "create-sparse-deallocs", ::llvm::cl::desc("Specify if the temporary buffers created by the sparse compiler should be deallocated. For compatibility with core bufferization passes. This option is only used when enable-runtime-library=false. See also create-deallocs for BufferizationOption."), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class SparseTensorConversionPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparseTensorConversionPassBase;

  SparseTensorConversionPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseTensorConversionPassBase(const SparseTensorConversionPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-tensor-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-tensor-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Convert sparse tensors and primitives to library calls"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseTensorConversionPass");
  }
  ::llvm::StringRef getName() const override { return "SparseTensorConversionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseTensorConversionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SparseVectorizationBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparseVectorizationBase;

  SparseVectorizationBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparseVectorizationBase(const SparseVectorizationBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-vectorization");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-vectorization"; }

  ::llvm::StringRef getDescription() const override { return "Vectorizes loops after sparsification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparseVectorization");
  }
  ::llvm::StringRef getName() const override { return "SparseVectorization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
    registry.insert<vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparseVectorizationBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int32_t> vectorLength{*this, "vl", ::llvm::cl::desc("Set the vector length (use 0 to disable vectorization)"), ::llvm::cl::init(0)};
  ::mlir::Pass::Option<bool> enableVLAVectorization{*this, "enable-vla-vectorization", ::llvm::cl::desc("Enable vector length agnostic vectorization"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> enableSIMDIndex32{*this, "enable-simd-index32", ::llvm::cl::desc("Enable i32 indexing into vectors (for efficient gather/scatter)"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class SparsificationAndBufferizationBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparsificationAndBufferizationBase;

  SparsificationAndBufferizationBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparsificationAndBufferizationBase(const SparsificationAndBufferizationBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparsification-and-bufferization");
  }
  ::llvm::StringRef getArgument() const override { return "sparsification-and-bufferization"; }

  ::llvm::StringRef getDescription() const override { return "Mini-pipeline that combines bufferization and sparsifiation"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparsificationAndBufferization");
  }
  ::llvm::StringRef getName() const override { return "SparsificationAndBufferization"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<gpu::GPUDialect>();
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparsificationAndBufferizationBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SparsificationPassBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = SparsificationPassBase;

  SparsificationPassBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SparsificationPassBase(const SparsificationPassBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparsification");
  }
  ::llvm::StringRef getArgument() const override { return "sparsification"; }

  ::llvm::StringRef getDescription() const override { return "Automatically generate sparse tensor code from sparse tensor types"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SparsificationPass");
  }
  ::llvm::StringRef getName() const override { return "SparsificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<affine::AffineDialect>();
    registry.insert<arith::ArithDialect>();
    registry.insert<bufferization::BufferizationDialect>();
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<linalg::LinalgDialect>();
    registry.insert<memref::MemRefDialect>();
    registry.insert<scf::SCFDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SparsificationPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<mlir::SparseParallelizationStrategy> parallelization{*this, "parallelization-strategy", ::llvm::cl::desc("Set the parallelization strategy"), ::llvm::cl::init(mlir::SparseParallelizationStrategy::kNone), llvm::cl::values(
             clEnumValN(mlir::SparseParallelizationStrategy::kNone, "none",
                        "Turn off sparse parallelization."),
             clEnumValN(mlir::SparseParallelizationStrategy::kDenseOuterLoop,
                        "dense-outer-loop",
                        "Enable dense outer loop sparse parallelization."),
             clEnumValN(mlir::SparseParallelizationStrategy::kAnyStorageOuterLoop,
                        "any-storage-outer-loop",
                        "Enable sparse parallelization regardless of storage for the outer loop."),
             clEnumValN(mlir::SparseParallelizationStrategy::kDenseAnyLoop,
                        "dense-any-loop",
                        "Enable dense parallelization for any loop."),
             clEnumValN(mlir::SparseParallelizationStrategy::kAnyStorageAnyLoop,
                        "any-storage-any-loop",
                        "Enable sparse parallelization for any storage and loop."))};
  ::mlir::Pass::Option<mlir::SparseEmitStrategy> sparseEmitStrategy{*this, "sparse-emit-strategy", ::llvm::cl::desc("Emit functional code or interfaces (to debug) for sparse loops"), ::llvm::cl::init(mlir::SparseEmitStrategy::kFunctional), llvm::cl::values(
             clEnumValN(mlir::SparseEmitStrategy::kFunctional, "functional",
                        "Emit functional code."),
             clEnumValN(mlir::SparseEmitStrategy::kDebugInterface, "debug-interface",
                        "Emit non-functional but easy-to-read interfaces to debug."))};
  ::mlir::Pass::Option<bool> enableRuntimeLibrary{*this, "enable-runtime-library", ::llvm::cl::desc("Enable runtime library for manipulating sparse tensors"), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class StageSparseOperationsBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = StageSparseOperationsBase;

  StageSparseOperationsBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  StageSparseOperationsBase(const StageSparseOperationsBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stage-sparse-ops");
  }
  ::llvm::StringRef getArgument() const override { return "stage-sparse-ops"; }

  ::llvm::StringRef getDescription() const override { return "Decompose a complex sparse operation into multiple stages"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StageSparseOperations");
  }
  ::llvm::StringRef getName() const override { return "StageSparseOperations"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StageSparseOperationsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StorageSpecifierToLLVMBase : public ::mlir::OperationPass<ModuleOp> {
public:
  using Base = StorageSpecifierToLLVMBase;

  StorageSpecifierToLLVMBase() : ::mlir::OperationPass<ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StorageSpecifierToLLVMBase(const StorageSpecifierToLLVMBase &other) : ::mlir::OperationPass<ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("sparse-storage-specifier-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "sparse-storage-specifier-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lower sparse storage specifer to llvm structure"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StorageSpecifierToLLVM");
  }
  ::llvm::StringRef getName() const override { return "StorageSpecifierToLLVM"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<arith::ArithDialect>();
    registry.insert<LLVM::LLVMDialect>();
    registry.insert<sparse_tensor::SparseTensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StorageSpecifierToLLVMBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
